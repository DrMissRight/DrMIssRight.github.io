[{"title":"Codeforces Round 926(Div . 2)","url":"/2024/03/01/Codeforces%20Round%20926%20(Div%20.%202)/","content":"Codefroces Round 926\nA就是最大值减去最小值\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\tint T; cin &gt;&gt; T;\twhile(T --) &#123;\t\tint n; cin &gt;&gt; n;\t\tvector&lt;int&gt; a(n);\t\tfor(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i];\t\tsort(a.begin(), a.end());\t\tcout &lt;&lt; a[n - 1] - a[0] &lt;&lt; &#x27;\\n&#x27;;\t&#125;\treturn 0;&#125;\n\nB我们对于所有点对角线分析得到，有 n 个底部加上 n - 2 顶端个格子，可以覆盖两个对角线，其他的只有一个\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;\tint T; cin &gt;&gt; T;\twhile(T -- ) &#123;\t\tint n, k; cin &gt;&gt; n &gt;&gt; k;\t\tint ans = 0;\t\tif(k &lt;= 4 * n - 4) &#123;\t\t\tans = (k + 1) / 2;\t\t&#125;\t\telse &#123;\t\t\tans = 2 * n - (4 * n - 2 - k);\t\t&#125;\t\t\tcout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;\t\t&#125;\treturn 0;&#125;\n\n","categories":["CF题解"]},{"title":"Codeforces Round 928 (Div . 4)","url":"/2024/03/01/Codeforces%20Round%20928%20(Div%20.%204)/","content":"Codeforces Round 928(Div . 4)\nA判断字母 A 和 B 谁出现的次数多即可\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;#define MAX_INT 0x7fffffffvoid solve() &#123;    string s; cin &gt;&gt; s;    int num1 = 0, num2 = 0;    for(int i = 0; i &lt; s.size(); ++ i) &#123;        if(s[i] == &#x27;A&#x27;)            num1 ++;        else            num2 ++;    &#125;    if(num1 &gt; num2) cout &lt;&lt; &#x27;A&#x27; &lt;&lt; &#x27;\\n&#x27;;    else cout &lt;&lt; &#x27;B&#x27; &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    int T = 1; cin &gt;&gt; T;    while(T --) solve();    return 0;&#125;\n\nB判断是否为正方形还是三角形，只需将每一行1的个数记录在数组中，然后判断，每行1的个数是否相等，若相等，则是”SQUARE” 反之，则是”TRIANGLE”\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;#define MAX_INT 0x7fffffffchar a[20][20],b[20];void solve() &#123;    int n; cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++ i)        for(int j = 1; j &lt;= n; ++ j)            cin &gt;&gt; a[i][j];    for(int i = 1; i &lt;= n; ++ i) &#123;        int num = 0;        for(int j = 1; j &lt;= n; ++ j) &#123;            if(a[i][j] == &#x27;1&#x27;)                num ++;        &#125;        b[i] = num;    &#125;    bool flag = false;    for(int i = 2; i &lt;=n; ++ i) &#123;        if(b[i] == b[i - 1] &amp;&amp; b[i] != 0)&#123;            flag = true;            break;        &#125;    &#125;    if(flag == true) cout &lt;&lt; &quot;SQUARE&quot; &lt;&lt; &#x27;\\n&#x27;;    else cout &lt;&lt; &quot;TRIANGLE&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    int T = 1; cin &gt;&gt; T;    while(T --) solve();    return 0;&#125;\n\nC利用前缀和对数据进行预处理，然后进行询问即可。注意：在进行前缀和预处理时，应该将处理过程放在T之前。总的时间复杂度为O(nlogn + T)\n#include &lt;bits/stdc++.h&gt;  using namespace std;  typedef long long ll;  typedef pair&lt;int, int&gt; PII;  #define MAX_INT 0x7fffffff  const int N = 2e5 + 10;  int a[N];  int f(int x) &#123;      int res = 0;      while(x != 0) &#123;          res += x % 10;          x /= 10;      &#125;      return res;  &#125;  void solve() &#123;     int n; cin &gt;&gt; n;     cout &lt;&lt; a[n] &lt;&lt; &#x27;\\n&#x27;;  &#125;  int main()  &#123;      ios::sync_with_stdio(false);      cin.tie(nullptr);      cout.tie(nullptr);      a[0] = 0;      for(int i = 1; i &lt;= N; ++ i)          a[i] = a[i - 1] + f(i);      int T = 1; cin &gt;&gt; T;      while(T --) solve();      return 0;  &#125;\n\nD一组内的数字最多只有两个，那么31个位置全都不一样，本质上就是两个值异或之后等于2147483647。\n我们可以采取一个做法，我们记录每一个值，然后就可以O(1)知道谁可以和它组合，这个组合也是符合一一对应的，也就是对方只能和你组合，那么我们可以用map取记录一下，然后就知道要和谁匹配。立刻的算出来，然后组合计算答案即可\n#include &lt;bits/stdc++.h&gt;  using namespace std;  typedef long long ll;  typedef pair&lt;int, int&gt; PII;  #define MAX_INT 0x7fffffff  int zhi = 2147483647;  void solve() &#123;      int n; cin &gt;&gt; n;      map&lt;int,int&gt; da; // 记录这个数值有哪些      vector&lt;int&gt; a(n);      int zong = n;      for(int i = 0; i &lt;= n- 1; i ++) &#123;          cin &gt;&gt; a[i];          da[a[i]] ++; // 对于每个数字，再去记录这个数字出现次数      &#125;      int ans = 0;      for(auto &amp;[x,y] : da) &#123;          int w = zhi ^ x; // 找到对应的值          int y1 = y,y2 = da[w];          int y3 = min(y1,y2); // 对于这两个数字一定只能选择最小，计算一下之后，就去消除掉在map中这个两个数字的多少          ans += y3; // 能成对的组数          zong -= 2 * y3;          da[x] -= y3;          da[w] -= y3;      &#125;      ans += zong; // 记录没有成对的数量      cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;  &#125;  int main()  &#123;      ios::sync_with_stdio(false);      cin.tie(nullptr);      cout.tie(nullptr);      int T = 1; cin &gt;&gt; T;      while(T --) solve();      return 0;  &#125;\n\n\n\n","categories":["CF题解"]},{"title":"Codeforces Round 925(Div.3)","url":"/2024/02/29/Codefores%20Round%20925%20(Div%20.%203)/","content":"\n\nCodeforces Round 925 (Div . 3)\nA暴力枚举所有三字母组合，并在其中寻找词性最小的一个(即字典序最小)即可。\n#include&lt;bits/stdc++.h&gt;using namespace std;void solve() &#123;\tint n, sz = 26;\tcin &gt;&gt; n;\tstring mins = &quot;zzz&quot;,cur;\tfor(int i = 0; i &lt; sz; ++ i) &#123;\t\tfor(int j = 0; j &lt; sz; ++ j) &#123;\t\t\tfor(int k = 0; k &lt; sz; ++ k) &#123;\t\t\t\tcur += char(i + &#x27;a&#x27;);\t\t\t\tcur += char(j + &#x27;a&#x27;);\t\t\t\tcur += char(k + &#x27;a&#x27;);\t\t\t\tmins = min(mins,cur);\t\t\t&#125;\t\t&#125;\t&#125;\tcout &lt;&lt; mins &lt;&lt; &#x27;\\n&#x27;;&#125;int main () &#123;\tint t; cin &gt;&gt; t;\twhile(t --) solve();\treturn 0;\t&#125;\n\nB先把前面的水放在1中，多余平均值的，将其进行记录，放到2中，然后再放在3中…….，直到水不够用输出NO，反之输出YES\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void solve() &#123;\tint n; cin &gt;&gt; n;\tvector&lt;ll&gt; a(n);\tfor(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i];\tll sum = 0;\tfor(int i = 0; i &lt; n; ++ i) sum += a[i];\tll num1 = sum / n; // 计算平均值\tll num2 = 0;\tfor(int i = 0; i &lt; n; ++ i) &#123;\t\tif(a[i] &gt;= num1) &#123; // 若当前位置水的数量大于平均值，则将多余的部分进行取出\t\t\tnum2 += abs(a[i] - num1);\t\t&#125;\t\telse &#123;\t\t\tll res = abs(a[i] - num1); // 若当前位置水的数量小于平均值，则用上述多余的部分进行补充\t\t\tif(res &gt; num2) &#123; // 如果无法补充，则直接输出NO\t\t\t\tcout &lt;&lt; &quot;NO&quot; &lt;&lt;&#x27;\\n&#x27;;\t\t\t\treturn;\t\t\t&#125;\t\t\telse &#123;\t\t\t\ta[i] += res;\t\t\t\tnum2 -= res;\t\t\t&#125;\t\t&#125;\t&#125;\t//反之 输出YES\tcout &lt;&lt; &quot;YES&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123;\tios::sync_with_stdio(false);\tcin.tie(nullptr);\tcout.tie(nullptr);\tint T = 1; cin &gt;&gt; T;\twhile(T --) solve();\treturn 0;&#125;\n\nC\n判断左边能保留多少个数字\n判断右边能保留多少个数字\n如果左边和右边可以合并的话，一共可以保留多少个数字\n最终计算花费的最少“布尔值”\n\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;#define ll long long#define MAX_INT 0x7fffffff#define int long longvoid solve() &#123;\tint n; cin &gt;&gt; n;\tvector&lt;int&gt; a(n);\tfor(int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i];\tint num1 = 0, num2 = 0, num3 = 0;\tint i = 0, j = n - 1;\tint ans = 0;\twhile(a[i] == a[0] &amp;&amp; i &lt;= n - 1) &#123;\t\tnum1 ++;\t\ti ++;\t&#125;\twhile(a[j] == a[n - 1] &amp;&amp; j &gt;= 0) &#123;\t\tnum2 ++;\t\tj --;\t&#125;\tif(a[0] == a[n - 1])\t\tnum3 = min(n, num1 + num2);\tans = n - max(num1, max(num2, num3));\tcout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;signed main() &#123;\tios::sync_with_stdio(false);\tcin.tie(nullptr);\tcout.tie(nullptr);\tint T = 1; cin &gt;&gt; T;\twhile(T --) solve();\treturn 0;&#125;\n\nD\n若是使用暴力做法，时间复杂度为O(n ^ 2)，爆时间；\n\n分析：\n （1）如何思考这种带条件的对数问题，首先看数据范围 2e5 那么基本上就要确定使用一些条件来代替这些具体的数字\n （2）在某些条件下，一些数字实际上是一个意思\n （3）首先ai - aj 被 y 整除，那么其实是 ai % y &#x3D;&#x3D; aj % y，那么我们需要记录所有a值对y 的取模。同理，ai + aj 被x整除，实际上(ai % x + aj % x) % x &#x3D;&#x3D; 0。\n （4）所以解决条件1的信息点，是所有a值对于x取模，只有相加的和模x为0，才符合条件1\n （5）所以满足顺序关系要在后面除去2，第一种是确定第二个条件，然后排序第一个条件，然后跑双指针\n （6）最简单的方法是，直接写一个map&lt;\\pair&lt;\\int,\\int&gt;,\\int&gt; da;\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; PII;#define MAX_INT 0x7fffffffconst int N = 2e5 + 10;int a[N];void solve() &#123;\tint n, x, y; cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;\tfor(int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i];\tmap&lt;int, map&lt;int,int&gt;&gt; mp;\tll ans = 0;\tfor(int i = 1; i &lt;= n; ++ i) &#123;\t\tans += mp[a[i] % y][(x - a[i] % x) % x];\t\tmp[a[i] % y][a[i] % x] ++;\t&#125;\tcout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123;\tios::sync_with_stdio(false);\tcin.tie(nullptr);\tcout.tie(nullptr);\tint T = 1; cin &gt;&gt; T;\twhile(T --) solve();\treturn 0;&#125;\n\nE（1）简单的博弈论实际上都是贪心问题，不小于10的m次方，实际上就是最后的长度要有 m + 1的长度，那么就会发现我们在乎的是数字的长度，而不是值。\n（2）对于Anna：一次颠倒，让最后的长度最小那么一定是删除了最多的末尾零，所以我们应该要在这次操作中删除更多的末尾零。\n（3）对于Sasha：我们要保留更多的末尾零，所以对于目前长度最长的末尾零来说，我们要把他合并起来。\n（4）所以贪心的思路为：记录数字末尾0的长度，然后排序从大到小按着顺序去删除\n#include&lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;#define MAX_INT 0x7fffffff#define int long long#define ll long longvoid solve() &#123;\tint n, m; cin &gt;&gt; n &gt;&gt; m;\tvector&lt;int&gt; a(n);\tint len = 0; // 记录所有数字总长度多少\tvector&lt;int&gt; b;\tfor(int i = 0; i &lt;= n - 1; ++ i) &#123;\t\tcin &gt;&gt; a[i];\t\tint zhi = a[i],res = 0, shu = 0;\t\tbool flag = false;\t\twhile(zhi) &#123; // res 记录目前末尾有多少个零\t\t\tif(zhi % 10 == 0) &#123;\t\t\t\tif(flag == false)\t\t\t\t\tres ++;\t\t\t&#125;\t\t\telse flag = true;\t\t\tshu ++;\t\t\tzhi /= 10;\t\t&#125;\t\tlen += shu; // shu 记录的是目前的数字长度多少\t\tb.push_back(res);\t&#125;\tsort(b.begin(), b.end()); // 把末尾为0去排序\tint chang = b.size();\tint cnt = 0;\tint shan = 0;\tfor(int i = chang - 1; i &gt;= 0; -- i) &#123; // 从大到小去删除\t\tif(cnt == 0) &#123; // 如果安娜先动\t\t\tshan += b[i]; // 删除目前的最长的点\t\t\tcnt = 1;\t\t&#125;\t\telse // 然后萨沙动，这个点就跳过去\t\t\tcnt = 0;\t&#125;\tif(len - shan &lt;= m) // 总长度 - 删除长度 小于等于 m 就是安娜获胜\t\tcout &lt;&lt; &quot;Anna&quot; &lt;&lt; &#x27;\\n&#x27;;\telse\t\tcout &lt;&lt; &quot;Sasha&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;signed main() &#123;\tios::sync_with_stdio(false);\tcin.tie(nullptr);\tcout.tie(nullptr);\tint T = 1; cin &gt;&gt; T;\twhile(T --) solve();\treturn 0;&#125;","categories":["CF题解"]},{"title":"Hexo Use Document","url":"/2024/02/29/Hexo%20Use%20Document/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"}]